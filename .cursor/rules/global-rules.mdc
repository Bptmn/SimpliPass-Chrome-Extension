---
alwaysApply: true
---

Important rule: do not answer in a way to satisfy me or my ego or saying that I am always abosultely right. I want you to challenge my demands according to best practices. Answer always according to the best practices. Propose improvement according to the best practices if my demands are not alignes with best coding practices.


## üß± Cursor Coding Constraints

### ‚úÖ Layer 1: Hooks (UI Layer)
- Simple, readable functions
- Handle UI state management
- Abstract complexity from components
- Return clear, predictable results
- Handle loading states and errors
- Ensure states are always accessible for UI
- Steps must be numbered (Step 1, Step 2, Step 3...)

### ‚úÖ Layer 2: Services (Business Logic Layer)
- Contain complex business logic
- Orchestrate multiple operations
- Handle data transformations
- Manage business rules
- Called only by hooks or other services
- Platform-agnostic

### ‚úÖ Layer 3: Libraries, Adapters and utils (External Integration Layer)
- Handle external API calls
- Platform-specific implementations (via adapters)
- Low-level operations (crypto, storage via utils)
- Called only by services
- Minimal business logic
- Focus on integration

### ‚úÖ Always Use
- React Native components (`<View>`, `<Text>`, etc.)
- Zustand for all state access and updates
- Platform adapter for secure local storage
- Absolute imports from `@common`, `@core`, `@mobile`, `@extension`, `@shared`
- Error boundaries and consistent return types in logic
- Custom error classes with layer-specific error handling

### ‚ùå Never Use
- `chrome.*` APIs outside `extension/`
- `any`/`unknown` types unless explicitly justified
- Direct Firestore/Storage SDKs in UI
- Raw access to keychain, storage, or memory in `app/` or `core/services/`
- Duplicate logic (always centralize in `common/services/`)
- `marginTop`/`marginBottom`: Use `gap` via layout classes only
- Business logic in hooks (only UI state management)
- External API calls in hooks (use services instead)
- Never set placeholder implementation in the code. This is a real implementation

---

## üß≠ Navigation (Rooting) Rules

- All navigation must be done through the global `useAppRouterContext()` or router prop passed via `AppRouterProvider`.
- Hooks that involve navigation (e.g. login, unlock, onboarding) must not use fallback callbacks like `onSuccess` ‚Äî they should use the router context directly.
- Never mix `router.navigateTo()` with alternative mechanisms (like calling a callback, mutating a parent state, or setting a redirect flag).
- Pages should never perform routing decisions directly. They delegate to hooks or business logic.
- Navigation must be centralized, explicit, and testable.

---

## üß† Cursor Memory Model

- UI reads from Zustand and secure local storage only (never directly for firestore)
- Platform-specific adapters restore vault and hydrate state on launch
- All decrypted values are ephemeral in RAM
- `logout()` must clear all RAM + persistent user secret
- Hooks manage UI state, services manage business logic, libraries handle external calls

---

## üìö Cursor Import Conventions


### Import Order
```ts
// External
import React from 'react';
// Hooks (Layer 1)
import { useLoginFlow } from '@core/hooks';
// Services (Layer 2)
import { loginUser } from '@core/services';
// Libraries (Layer 3)
import { loginWithCognito } from '@core/libraries';
// Types
import type { LoginResult } from '@core/types';
```

---

## üîê Platform Secure Storage

### Mobile
- Use `expo-secure-store`

### Extension
- Use chrome.storage.session

---

## üõ°Ô∏è Error Handling Strategy

### Custom Error Classes
```typescript
// Base error class
export class SimpliPassError extends Error {
  constructor(
    message: string,
    public code: string,
    public layer: 'hook' | 'service' | 'library',
    public originalError?: Error
  ) {
    super(message);
    this.name = 'SimpliPassError';
  }
}

// Layer-specific errors
export class AuthenticationError extends SimpliPassError {
  constructor(message: string, originalError?: Error) {
    super(message, 'AUTH_ERROR', 'service', originalError);
    this.name = 'AuthenticationError';
  }
}
```

---

## ‚òëÔ∏è Build Checklist

After every major change, always run:
```bash
npm run lint
npm run test
npm run build
```

Cursor must fix all errors and validate the code before considering the task done.

---

## ü§ñ Cursor Summary Rules

- Follow three-layer architecture: Hooks ‚Üí Services ‚Üí Libraries
- Never bypass platformAdapter
- Never persist decrypted data
- Never write platform logic in `common/` or `core/services/`
- Always validate types, tests, build
- Only use Zustand for UI-bound data
- Run full validation cycle after structural changes
- Keep hooks simple and UI-focused
- Keep services business-logic focused
- Keep libraries integration-focused

- Never write platform logic in `common/` or `core/logic/`
- Always validate types, tests, build
- Only use Zustand for UI-bound data
- Run full validation cycle after structural changes
