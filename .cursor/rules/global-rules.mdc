---
description: SimpliPass Cursor Global Rules â€“ Post-Refactor Architecture
globs: 
alwaysApply: true
---

# ğŸ“ SimpliPass â€“ Global Cursor Rules  
*(Unified Monorepo for Mobile & Extension â€“ React Native / Manifest V3)*

## ğŸ§  Architecture Foundations

### âœ… Single Source of Truth
All UI data must come from memory (Zustand states). UI logic never fetches directly from storage or network.

### âœ… Platform Separation
- Shared UI and logic must remain platform-agnostic (in `app/` and `core/`)
- Platform-specific logic must be isolated in `mobile/` or `extension/`
- Use `core/adapters/platform.adapter.ts` to abstract all platform-specific implementations

### âœ… Feature Verticalization
Related business logic should be grouped by domain (e.g. credentials, auth) within `core/`.

### âœ… Secure by Design
- No decrypted data is ever persisted
- All encryption/decryption handled via `core/crypto` or `core/utils/encryption`
- Platform-specific persistence must use encrypted local storage or secure keychain

---

## ğŸ“ Package Responsibilities

```
packages/
â”œâ”€â”€ app/        â†’ Shared UI (popup + mobile)
â”œâ”€â”€ core/       â†’ Platform-agnostic logic, auth, state, crypto
â”œâ”€â”€ mobile/     â†’ Mobile-specific services, keychain access
â”œâ”€â”€ extension/  â†’ Chrome-specific background, content, storage
```

---

## ğŸ§© Cursor Execution Strategy

### âœ… Cursor Must Always
- Think â†’ Plan â†’ Execute â†’ Report
- Organize changes by domain (update types â†’ logic â†’ UI)
- Use `platform.adapter.ts` for cross-platform logic
- Update related tests to reflect changes
- Update related readme file to reflect changes
- Validate with:
```bash
npm run lint && npm run build && npm run test
```

### ğŸ§ª Testing
- All business logic must have `*.test.ts`
- All UI components must have `*.test.tsx` and `*.stories.tsx`
- Include `testID` and `accessibilityLabel` for interactive UI

### ğŸ¨ Design System
- Use `@/core/design/tokens` for color, spacing, typography
- Structure layout using `pageContainer`, `scrollView`, etc.
- Never use inline styles or hardcoded values

---

## ğŸ§± Cursor Coding Constraints

### âœ… Always Use
- React Native components (`<View>`, `<Text>`, etc.)
- Zustand for all state access and updates
- Absolute imports from `@app`, `@core`, `@mobile`, `@extension`, `@shared`
- Error boundaries and consistent return types in logic

### âŒ Never Use
- `chrome.*` APIs outside `extension/`
- `any`/`unknown` types unless explicitly justified
- Direct Firestore/Storage SDKs in UI
- Raw access to keychain, storage, or memory in `app/` or `core/logic/`
- Duplicate logic (always centralize in `core/logic/`)
- `marginTop`/`marginBottom`: Use `gap` via layout classes only

---

## ğŸ§  Cursor Memory Model

- UI reads from Zustand only (no storage fallback)
- Platform-specific adapters restore vault and hydrate state on launch
- All decrypted values are ephemeral in RAM
- `logout()` must clear all RAM + persistent user secret

---

## ğŸ“š Cursor File Naming & Import Conventions

### File Names
```
Components:      CredentialCard.tsx
Stores:          credentials.state.ts
Hooks:           useBiometry.ts
Utilities:       decryptVault.ts
Types:           types.ts / interfaces.ts
Tests:           *.test.ts(x)
Stories:         *.stories.tsx
```

### Import Order
```ts
// External
import React from 'react';
// Aliased
import { loginUser } from '@core/logic/auth';
// Relative
import styles from './styles';
```

---

## ğŸ” Platform Secure Storage

### Mobile
- Use `expo-secure-store` to persist `userSecretKey`
- Decrypt on app launch â†’ hydrate state

### Extension
- Encrypt `userSecretKey` with `deviceFingerprintKey`
- Store encrypted version in `chrome.storage.local`
- Decrypt in background â†’ load RAM vault

---

## â˜‘ï¸ Build Checklist

After every major change, always run:
```bash
npm run lint
npm run test
npm run build
```

Cursor must fix all errors and validate the code before considering the task done.

---

## ğŸ¤– Cursor Summary Rules

- Never bypass platformAdapter
- Never persist decrypted data
- Never write platform logic in `app/` or `core/logic/`
- Always validate types, tests, build
- Only use Zustand for UI-bound data
- Run full validation cycle after structural changes
