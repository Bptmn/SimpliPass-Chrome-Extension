{"version":3,"mappings":"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","names":["setCredentialsInMemory","setBankCardsInMemory","setSecureNotesInMemory"],"ignoreList":[],"sources":["../packages/extension/utils/autofillBridge.ts","../packages/extension/background.ts"],"sourcesContent":["/**\n * Bridge utility for connecting extension autofill logic with core vault system\n * Provides safe access to decrypted vault data with proper session validation\n */\n\nimport { loadVaultIfNeeded } from './vaultLoader';\nimport { getAllItemsFromMemory } from '../session/memory';\n\n/**\n * Extracts the root domain from a hostname, removing 'www.' and subdomains.\n * @param hostname The full hostname (e.g., 'www.example.co.uk')\n * @returns The root domain (e.g., 'example.co.uk')\n */\nfunction getRootDomain(hostname: string): string {\n  const parts = hostname.split('.').filter(Boolean);\n  if (parts.length <= 2) return hostname.replace(/^www\\./, '');\n  return parts.slice(-2).join('.');\n}\n\n/**\n * Check if autofill is available (valid session exists)\n * @returns true if autofill can be used, false otherwise\n */\nexport function isAutofillAvailable(): boolean {\n  return getAllItemsFromMemory().credentials.length > 0;\n}\n\n/**\n * Get matching credentials for a domain with session validation\n * @param domain The domain to match against\n * @returns Array of matching credentials (non-sensitive data only)\n */\nexport function getMatchingCredentials(domain: string): Array<{\n  id: string;\n  title: string;\n  username: string;\n  url?: string;\n}> {\n  try {\n    // Check if session is valid before accessing decrypted data\n    if (!isAutofillAvailable()) {\n      console.log('[AutofillBridge] No valid session for autofill');\n      return [];\n    }\n\n    const items = getAllItemsFromMemory();\n    const credentials = items.credentials;\n    const pageRootDomain = getRootDomain(domain);\n    \n    return credentials\n      .filter(credential => {\n        if (!credential.url) return false;\n        \n        const credRootDomain = getRootDomain(credential.url);\n        const credDomain = credential.url;\n        \n        // Exact domain match\n        if (credDomain === domain || credDomain === pageRootDomain) {\n          return true;\n        }\n        \n        // Root domain match\n        if (credRootDomain === pageRootDomain) {\n          return true;\n        }\n        \n        // Subdomain match (e.g., login.example.com matches example.com)\n        if (domain.includes(credRootDomain) && domain !== credRootDomain) {\n          return true;\n        }\n        \n        return false;\n      })\n      .map(credential => ({\n        id: credential.id,\n        title: credential.title,\n        username: credential.username,\n        url: credential.url\n      }));\n  } catch (error) {\n    console.error('[AutofillBridge] Error finding matching credentials:', error);\n    return [];\n  }\n}\n\n/**\n * Get full credential data for injection (with password)\n * @param credentialId The ID of the credential to retrieve\n * @returns Full credential data or null if not found\n */\nexport function getCredentialForInjection(credentialId: string): {\n  id: string;\n  title: string;\n  username: string;\n  password: string;\n  url?: string;\n} | null {\n  try {\n    // Check if session is valid before accessing decrypted data\n    if (!isAutofillAvailable()) {\n      console.log('[AutofillBridge] No valid session for credential injection');\n      return null;\n    }\n\n    const items = getAllItemsFromMemory();\n    return items.credentials.find(c => c.id === credentialId) || null;\n  } catch (error) {\n    console.error('[AutofillBridge] Error getting credential for injection:', error);\n    return null;\n  }\n}\n\n/**\n * Restore vault if session is valid\n * @returns Promise<boolean> true if vault was restored successfully\n */\nexport async function restoreVaultForAutofill(): Promise<boolean> {\n  try {\n    await loadVaultIfNeeded();\n    return true;\n  } catch (error) {\n    console.error('[AutofillBridge] Error restoring vault:', error);\n    return false;\n  }\n}\n\n/**\n * Get all available credentials for current session\n * @returns Array of all credentials (non-sensitive data only)\n */\nexport function getAllCredentials(): Array<{\n  id: string;\n  title: string;\n  username: string;\n  url?: string;\n}> {\n  try {\n    if (!isAutofillAvailable()) {\n      return [];\n    }\n\n    const items = getAllItemsFromMemory();\n    return items.credentials.map(credential => ({\n      id: credential.id,\n      title: credential.title,\n      username: credential.username,\n      url: credential.url\n    }));\n  } catch (error) {\n    console.error('[AutofillBridge] Error getting all credentials:', error);\n    return [];\n  }\n}\n\n/**\n * Get all available bank cards for current session\n * @returns Array of all bank cards (non-sensitive data only)\n */\nexport function getAllBankCards(): Array<{\n  id: string;\n  title: string;\n  cardNumber: string;\n  url?: string;\n}> {\n  try {\n    if (!isAutofillAvailable()) {\n      return [];\n    }\n\n    const items = getAllItemsFromMemory();\n    return items.bankCards.map(card => ({\n      id: card.id,\n      title: card.title,\n      cardNumber: card.cardNumber,\n      url: card.url\n    }));\n  } catch (error) {\n    console.error('[AutofillBridge] Error getting all bank cards:', error);\n    return [];\n  }\n}\n\n/**\n * Get all available secure notes for current session\n * @returns Array of all secure notes (non-sensitive data only)\n */\nexport function getAllSecureNotes(): Array<{\n  id: string;\n  title: string;\n  url?: string;\n}> {\n  try {\n    if (!isAutofillAvailable()) {\n      return [];\n    }\n\n    const items = getAllItemsFromMemory();\n    return items.secureNotes.map(note => ({\n      id: note.id,\n      title: note.title,\n      url: note.url\n    }));\n  } catch (error) {\n    console.error('[AutofillBridge] Error getting all secure notes:', error);\n    return [];\n  }\n} \n\nexport async function getVaultForAutofill() {\n  let items = getAllItemsFromMemory();\n  if (\n    items.credentials.length === 0 &&\n    items.bankCards.length === 0 &&\n    items.secureNotes.length === 0\n  ) {\n    await loadVaultIfNeeded();\n    items = getAllItemsFromMemory();\n  }\n  return items;\n} ","import { PageState } from '@app/core/types/types';\nimport { \n  isAutofillAvailable,\n  getMatchingCredentials,\n  getCredentialForInjection,\n  restoreVaultForAutofill\n} from './utils/autofillBridge';\nimport { loadVaultIfNeeded } from './utils/vaultLoader';\n\n/**\n * Stores page info per tab.\n */\nconst pageState: { [tabId: number]: PageState } = {};\n\n// Forward background logs to content scripts\nconst originalConsoleLog = console.log;\nconst originalConsoleError = console.error;\nconst originalConsoleWarn = console.warn;\n\n// Store active tabs that have content scripts\nconst activeContentScriptTabs = new Set<number>();\n\n/**\n * Ensure vault is loaded in memory\n */\nasync function ensureVaultLoaded(): Promise<boolean> {\n  try {\n    await loadVaultIfNeeded();\n    return true;\n  } catch (error) {\n    console.error('[Background] Failed to load vault:', error);\n    return false;\n  }\n}\n\n// Function to forward logs to content scripts\nfunction forwardLogToContentScripts(level: 'log' | 'error' | 'warn', message: string) {\n  // Only forward to tabs that we know have content scripts\n  activeContentScriptTabs.forEach(tabId => {\n    chrome.tabs.sendMessage(tabId, {\n      type: 'BACKGROUND_LOG',\n      level,\n      message\n    }).catch(() => {\n      // Remove tab from active set if content script is no longer available\n      activeContentScriptTabs.delete(tabId);\n    });\n  });\n}\n\nconsole.log = (...args) => {\n  originalConsoleLog(...args);\n  forwardLogToContentScripts('log', args.join(' '));\n};\n\nconsole.error = (...args) => {\n  originalConsoleError(...args);\n  forwardLogToContentScripts('error', args.join(' '));\n};\n\nconsole.warn = (...args) => {\n  originalConsoleWarn(...args);\n  forwardLogToContentScripts('warn', args.join(' '));\n};\n\nchrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {\n  // Register content script with background for log forwarding\n  if (msg.type === 'CONTENT_SCRIPT_READY' && sender.tab?.id != null) {\n    activeContentScriptTabs.add(sender.tab.id);\n    console.log('[Background] Content script registered for tab:', sender.tab.id);\n    \n    // Always try to load vault when content script registers\n    ensureVaultLoaded();\n  }\n  \n  // Store page info\n  if (msg.type === 'PAGE_INFO' && sender.tab?.id != null) {\n    pageState[sender.tab.id] = { url: msg.url, domain: msg.domain, hasLoginForm: msg.hasLoginForm };\n  }\n\n  // Popup requests current page state\n  if (msg.type === 'GET_PAGE_STATE' && msg.tabId != null) {\n    sendResponse(pageState[msg.tabId] || null);\n    return true;\n  }\n\n  // Handle session status request\n  if (msg.type === 'GET_SESSION_STATUS') {\n    (async () => {\n      // Always try to ensure vault is loaded before responding\n      await ensureVaultLoaded();\n      \n      // Check if autofill is available\n      const isValid = isAutofillAvailable();\n      sendResponse({ isValid });\n    })();\n    return true;\n  }\n\n  // Handle matching credentials request from content script\n  if (msg.type === 'GET_MATCHING_CREDENTIALS' && msg.domain) {\n    (async () => {\n      // Always try to ensure vault is loaded before getting credentials\n      await ensureVaultLoaded();\n      \n      const matchingCredentials = getMatchingCredentials(msg.domain);\n      sendResponse({ credentials: matchingCredentials });\n    })();\n    return true;\n  }\n\n  // Handle credential injection request\n  if (msg.type === 'INJECT_CREDENTIAL' && msg.credentialId && sender.tab?.id) {\n    (async () => {\n      try {\n        const credential = getCredentialForInjection(msg.credentialId);\n        \n        if (!credential) {\n          sendResponse({ success: false, error: 'Credential not found or vault not loaded' });\n          return;\n        }\n\n        // Send credential data to content script for injection\n        if (sender.tab && typeof sender.tab.id === 'number') {\n          chrome.tabs.sendMessage(sender.tab.id, {\n            type: 'INJECT_CREDENTIAL',\n            username: credential.username,\n            password: credential.password\n          });\n        }\n        \n        sendResponse({ success: true });\n      } catch (error) {\n        console.error('[Background] Error injecting credential:', error);\n        sendResponse({ success: false, error: error instanceof Error ? error.message : 'Unknown error' });\n      }\n    })();\n    return true;\n  }\n\n  // Handle vault restoration request\n  if (msg.type === 'RESTORE_VAULT') {\n    (async () => {\n      try {\n        const restored = await restoreVaultForAutofill();\n        sendResponse({ success: restored });\n      } catch (error) {\n        console.error('[Background] Error restoring vault:', error);\n        sendResponse({ success: false, error: error instanceof Error ? error.message : 'Unknown error' });\n      }\n    })();\n    return true;\n  }\n\n  // Handle vault sync from popup\n  if (msg.type === 'SYNC_VAULT' && msg.vaultData) {\n    (async () => {\n      try {\n        // Import the memory module to store vault data\n        const { setCredentialsInMemory, setBankCardsInMemory, setSecureNotesInMemory } = await import('./session/memory');\n        \n        setCredentialsInMemory(msg.vaultData.credentials || []);\n        setBankCardsInMemory(msg.vaultData.bankCards || []);\n        setSecureNotesInMemory(msg.vaultData.secureNotes || []);\n        \n        console.log('[Background] Vault synced from popup');\n        sendResponse({ success: true });\n      } catch (error) {\n        console.error('[Background] Error syncing vault from popup:', error);\n        sendResponse({ success: false, error: error instanceof Error ? error.message : 'Unknown error' });\n      }\n    })();\n    return true;\n  }\n});\n\n// Handle tab updates to clean up page state\nchrome.tabs.onRemoved.addListener((tabId) => {\n  delete pageState[tabId];\n  activeContentScriptTabs.delete(tabId);\n  console.log('[Background] Tab removed, cleaned up state for tab:', tabId);\n});\n\n// Handle extension startup\nchrome.runtime.onStartup.addListener(() => {\n  console.log('[Background] Extension started, loading vault...');\n  ensureVaultLoaded();\n});\n\n// Handle extension installation/update\nchrome.runtime.onInstalled.addListener(() => {\n  console.log('[Background] Extension installed/updated, loading vault...');\n  ensureVaultLoaded();\n});\n\n// Handle tab activation to ensure vault is loaded\nchrome.tabs.onActivated.addListener(() => {\n  console.log('[Background] Tab activated, ensuring vault is loaded...');\n  ensureVaultLoaded();\n});\n\n// Handle tab updates to ensure vault is loaded\nchrome.tabs.onUpdated.addListener((tabId, changeInfo) => {\n  if (changeInfo.status === 'complete') {\n    console.log('[Background] Tab updated, ensuring vault is loaded for tab:', tabId);\n    ensureVaultLoaded();\n  }\n});\n"],"file":"background.js"}