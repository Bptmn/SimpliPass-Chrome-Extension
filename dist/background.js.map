{"version":3,"mappings":"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","names":["setCredentialsInMemory","setBankCardsInMemory","setSecureNotesInMemory"],"ignoreList":[],"sources":["../packages/extension/utils/vaultLoader.ts","../packages/extension/utils/autofillBridge.ts","../packages/extension/background.ts"],"sourcesContent":["import { decryptData } from '@app/utils/crypto';\nimport { useCredentialsStore, useBankCardsStore, useSecureNotesStore } from '@app/core/states';\n\nconst USER_SECRET_KEY_STORAGE = 'simplipass_persistent_user_secret_key';\nconst VAULT_ENCRYPTED_STORAGE = 'simplipass_encrypted_vault';\n\n/**\n * Decrypts the vault using the userSecretKey\n * @param vaultEncrypted - The encrypted vault string\n * @param userSecretKey - The decrypted user secret key\n * @returns The decrypted vault object or null\n */\nexport async function decryptVaultWithUserSecretKey(vaultEncrypted: string, userSecretKey: string): Promise<any | null> {\n  try {\n    const decrypted = await decryptData(vaultEncrypted, userSecretKey);\n    if (!decrypted) return null;\n    return JSON.parse(decrypted);\n  } catch (e) {\n    console.error('[VaultLoader] Failed to decrypt vault:', e);\n    return null;\n  }\n}\n\n/**\n * Loads the vault into memory if not already present\n * - Loads userSecretKeyEncrypted from storage\n * - Decrypts with deviceFingerprintKey\n * - Loads vaultEncrypted and decrypts with userSecretKey\n * - Populates states with vault data\n */\nexport async function loadVaultIfNeeded(): Promise<void> {\n  const credentialsStore = useCredentialsStore.getState();\n  const bankCardsStore = useBankCardsStore.getState();\n  const secureNotesStore = useSecureNotesStore.getState();\n  \n  // Check if vault is already loaded in states\n  if (\n    credentialsStore.credentials.length > 0 ||\n    bankCardsStore.bankCards.length > 0 ||\n    secureNotesStore.secureNotes.length > 0\n  ) {\n    return;\n  }\n  \n  try {\n    // 1. Load userSecretKeyEncrypted from storage\n    const userKeyResult = await chrome.storage.local.get([USER_SECRET_KEY_STORAGE]);\n    const userKeyData = userKeyResult[USER_SECRET_KEY_STORAGE];\n    if (!userKeyData || !userKeyData.encryptedKey) {\n      console.warn('[VaultLoader] No persistent userSecretKey found');\n      return;\n    }\n    \n    // 2. Derive deviceFingerprintKey\n    // Note: This would need to be implemented or imported from the correct location\n    // const fingerprintKey = await generateStableFingerprintKey();\n    \n    // 3. Decrypt userSecretKey\n    // const userSecretKey = await decryptData(userKeyData.encryptedKey, fingerprintKey);\n    // if (!userSecretKey) {\n    //   console.warn('[VaultLoader] Failed to decrypt userSecretKey');\n    //   return;\n    // }\n    \n    // 4. Load vaultEncrypted from storage\n    const vaultResult = await chrome.storage.local.get([VAULT_ENCRYPTED_STORAGE]);\n    const vaultEncrypted = vaultResult[VAULT_ENCRYPTED_STORAGE];\n    if (!vaultEncrypted) {\n      console.warn('[VaultLoader] No encrypted vault found');\n      return;\n    }\n    \n    // 5. Decrypt vault\n    // const vault = await decryptVaultWithUserSecretKey(vaultEncrypted, userSecretKey);\n    // if (!vault) {\n    //   console.warn('[VaultLoader] Failed to decrypt vault');\n    //   return;\n    // }\n    \n    // 6. Store in states\n    // credentialsStore.setCredentials(vault.credentials || []);\n    // bankCardsStore.setBankCards(vault.bankCards || []);\n    // secureNotesStore.setSecureNotes(vault.secureNotes || []);\n    console.log('[VaultLoader] Vault loading logic updated to use states');\n  } catch (e) {\n    console.error('[VaultLoader] Error loading vault:', e);\n  }\n} ","/**\n * Bridge utility for connecting extension autofill logic with core vault system\n * Provides safe access to decrypted vault data with proper session validation\n */\n\nimport { loadVaultIfNeeded } from './vaultLoader';\nimport { useCredentialsStore, useBankCardsStore, useSecureNotesStore } from '@app/core/states';\n\n/**\n * Extracts the root domain from a hostname, removing 'www.' and subdomains.\n * @param hostname The full hostname (e.g., 'www.example.co.uk')\n * @returns The root domain (e.g., 'example.co.uk')\n */\nfunction getRootDomain(hostname: string): string {\n  const parts = hostname.split('.').filter(Boolean);\n  if (parts.length <= 2) return hostname.replace(/^www\\./, '');\n  return parts.slice(-2).join('.');\n}\n\n/**\n * Check if autofill is available (valid session exists)\n * @returns true if autofill can be used, false otherwise\n */\nexport function isAutofillAvailable(): boolean {\n  const credentialsStore = useCredentialsStore.getState();\n  return credentialsStore.credentials.length > 0;\n}\n\n/**\n * Get matching credentials for a domain with session validation\n * @param domain The domain to match against\n * @returns Array of matching credentials (non-sensitive data only)\n */\nexport function getMatchingCredentials(domain: string): Array<{\n  id: string;\n  title: string;\n  username: string;\n  url?: string;\n}> {\n  try {\n    // Check if session is valid before accessing decrypted data\n    if (!isAutofillAvailable()) {\n      console.log('[AutofillBridge] No valid session for autofill');\n      return [];\n    }\n\n    const credentialsStore = useCredentialsStore.getState();\n    const credentials = credentialsStore.credentials;\n    const pageRootDomain = getRootDomain(domain);\n    \n    return credentials\n      .filter(credential => {\n        if (!credential.url) return false;\n        \n        const credRootDomain = getRootDomain(credential.url);\n        const credDomain = credential.url;\n        \n        // Exact domain match\n        if (credDomain === domain || credDomain === pageRootDomain) {\n          return true;\n        }\n        \n        // Root domain match\n        if (credRootDomain === pageRootDomain) {\n          return true;\n        }\n        \n        // Subdomain match (e.g., login.example.com matches example.com)\n        if (domain.includes(credRootDomain) && domain !== credRootDomain) {\n          return true;\n        }\n        \n        return false;\n      })\n      .map(credential => ({\n        id: credential.id,\n        title: credential.title,\n        username: credential.username,\n        url: credential.url\n      }));\n  } catch (error) {\n    console.error('[AutofillBridge] Error finding matching credentials:', error);\n    return [];\n  }\n}\n\n/**\n * Get full credential data for injection (with password)\n * @param credentialId The ID of the credential to retrieve\n * @returns Full credential data or null if not found\n */\nexport function getCredentialForInjection(credentialId: string): {\n  id: string;\n  title: string;\n  username: string;\n  password: string;\n  url?: string;\n} | null {\n  try {\n    // Check if session is valid before accessing decrypted data\n    if (!isAutofillAvailable()) {\n      console.log('[AutofillBridge] No valid session for credential injection');\n      return null;\n    }\n\n    const credentialsStore = useCredentialsStore.getState();\n    return credentialsStore.credentials.find(c => c.id === credentialId) || null;\n  } catch (error) {\n    console.error('[AutofillBridge] Error getting credential for injection:', error);\n    return null;\n  }\n}\n\n/**\n * Restore vault if session is valid\n * @returns Promise<boolean> true if vault was restored successfully\n */\nexport async function restoreVaultForAutofill(): Promise<boolean> {\n  try {\n    await loadVaultIfNeeded();\n    return true;\n  } catch (error) {\n    console.error('[AutofillBridge] Error restoring vault:', error);\n    return false;\n  }\n}\n\n/**\n * Get all available credentials for current session\n * @returns Array of all credentials (non-sensitive data only)\n */\nexport function getAllCredentials(): Array<{\n  id: string;\n  title: string;\n  username: string;\n  url?: string;\n}> {\n  try {\n    if (!isAutofillAvailable()) {\n      return [];\n    }\n\n    const credentialsStore = useCredentialsStore.getState();\n    return credentialsStore.credentials.map(credential => ({\n      id: credential.id,\n      title: credential.title,\n      username: credential.username,\n      url: credential.url\n    }));\n  } catch (error) {\n    console.error('[AutofillBridge] Error getting all credentials:', error);\n    return [];\n  }\n}\n\n/**\n * Get all available bank cards for current session\n * @returns Array of all bank cards (non-sensitive data only)\n */\nexport function getAllBankCards(): Array<{\n  id: string;\n  title: string;\n  cardNumber: string;\n  url?: string;\n}> {\n  try {\n    if (!isAutofillAvailable()) {\n      return [];\n    }\n\n    const bankCardsStore = useBankCardsStore.getState();\n    return bankCardsStore.bankCards.map(card => ({\n      id: card.id,\n      title: card.title,\n      cardNumber: card.cardNumber,\n      url: 'url' in card ? (card as any).url : '',\n    }));\n  } catch (error) {\n    console.error('[AutofillBridge] Error getting all bank cards:', error);\n    return [];\n  }\n}\n\n/**\n * Get all available secure notes for current session\n * @returns Array of all secure notes (non-sensitive data only)\n */\nexport function getAllSecureNotes(): Array<{\n  id: string;\n  title: string;\n  url?: string;\n}> {\n  try {\n    if (!isAutofillAvailable()) {\n      return [];\n    }\n\n    const secureNotesStore = useSecureNotesStore.getState();\n    return secureNotesStore.secureNotes.map(note => ({\n      id: note.id,\n      title: note.title,\n      url: 'url' in note ? (note as any).url : '',\n    }));\n  } catch (error) {\n    console.error('[AutofillBridge] Error getting all secure notes:', error);\n    return [];\n  }\n} \n\nexport async function getVaultForAutofill() {\n  const credentialsStore = useCredentialsStore.getState();\n  const bankCardsStore = useBankCardsStore.getState();\n  const secureNotesStore = useSecureNotesStore.getState();\n  \n  if (\n    credentialsStore.credentials.length === 0 &&\n    bankCardsStore.bankCards.length === 0 &&\n    secureNotesStore.secureNotes.length === 0\n  ) {\n    await loadVaultIfNeeded();\n  }\n  \n  return {\n    credentials: credentialsStore.credentials,\n    bankCards: bankCardsStore.bankCards,\n    secureNotes: secureNotesStore.secureNotes,\n  };\n} ","import { PageState } from '@app/core/types/types';\nimport { \n  isAutofillAvailable,\n  getMatchingCredentials,\n  getCredentialForInjection,\n  restoreVaultForAutofill\n} from './utils/autofillBridge';\nimport { loadVaultIfNeeded } from './utils/vaultLoader';\n\n/**\n * Stores page info per tab.\n */\nconst pageState: { [tabId: number]: PageState } = {};\n\n// Forward background logs to content scripts\nconst originalConsoleLog = console.log;\nconst originalConsoleError = console.error;\nconst originalConsoleWarn = console.warn;\n\n// Store active tabs that have content scripts\nconst activeContentScriptTabs = new Set<number>();\n\n/**\n * Ensure vault is loaded in memory\n */\nasync function ensureVaultLoaded(): Promise<boolean> {\n  try {\n    await loadVaultIfNeeded();\n    return true;\n  } catch (error) {\n    console.error('[Background] Failed to load vault:', error);\n    return false;\n  }\n}\n\n// Function to forward logs to content scripts\nfunction forwardLogToContentScripts(level: 'log' | 'error' | 'warn', message: string) {\n  // Only forward to tabs that we know have content scripts\n  activeContentScriptTabs.forEach(tabId => {\n    chrome.tabs.sendMessage(tabId, {\n      type: 'BACKGROUND_LOG',\n      level,\n      message\n    }).catch(() => {\n      // Remove tab from active set if content script is no longer available\n      activeContentScriptTabs.delete(tabId);\n    });\n  });\n}\n\nconsole.log = (...args) => {\n  originalConsoleLog(...args);\n  forwardLogToContentScripts('log', args.join(' '));\n};\n\nconsole.error = (...args) => {\n  originalConsoleError(...args);\n  forwardLogToContentScripts('error', args.join(' '));\n};\n\nconsole.warn = (...args) => {\n  originalConsoleWarn(...args);\n  forwardLogToContentScripts('warn', args.join(' '));\n};\n\nchrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {\n  // Register content script with background for log forwarding\n  if (msg.type === 'CONTENT_SCRIPT_READY' && sender.tab?.id != null) {\n    activeContentScriptTabs.add(sender.tab.id);\n    console.log('[Background] Content script registered for tab:', sender.tab.id);\n    \n    // Always try to load vault when content script registers\n    ensureVaultLoaded();\n  }\n  \n  // Store page info\n  if (msg.type === 'PAGE_INFO' && sender.tab?.id != null) {\n    pageState[sender.tab.id] = { url: msg.url, domain: msg.domain, hasLoginForm: msg.hasLoginForm };\n  }\n\n  // Popup requests current page state\n  if (msg.type === 'GET_PAGE_STATE' && msg.tabId != null) {\n    sendResponse(pageState[msg.tabId] || null);\n    return true;\n  }\n\n  // Handle session status request\n  if (msg.type === 'GET_SESSION_STATUS') {\n    (async () => {\n      // Always try to ensure vault is loaded before responding\n      await ensureVaultLoaded();\n      \n      // Check if autofill is available\n      const isValid = isAutofillAvailable();\n      sendResponse({ isValid });\n    })();\n    return true;\n  }\n\n  // Handle matching credentials request from content script\n  if (msg.type === 'GET_MATCHING_CREDENTIALS' && msg.domain) {\n    (async () => {\n      // Always try to ensure vault is loaded before getting credentials\n      await ensureVaultLoaded();\n      \n      const matchingCredentials = getMatchingCredentials(msg.domain);\n      sendResponse({ credentials: matchingCredentials });\n    })();\n    return true;\n  }\n\n  // Handle credential injection request\n  if (msg.type === 'INJECT_CREDENTIAL' && msg.credentialId && sender.tab?.id) {\n    (async () => {\n      try {\n        const credential = getCredentialForInjection(msg.credentialId);\n        \n        if (!credential) {\n          sendResponse({ success: false, error: 'Credential not found or vault not loaded' });\n          return;\n        }\n\n        // Send credential data to content script for injection\n        if (sender.tab && typeof sender.tab.id === 'number') {\n          chrome.tabs.sendMessage(sender.tab.id, {\n            type: 'INJECT_CREDENTIAL',\n            username: credential.username,\n            password: credential.password\n          });\n        }\n        \n        sendResponse({ success: true });\n      } catch (error) {\n        console.error('[Background] Error injecting credential:', error);\n        sendResponse({ success: false, error: error instanceof Error ? error.message : 'Unknown error' });\n      }\n    })();\n    return true;\n  }\n\n  // Handle vault restoration request\n  if (msg.type === 'RESTORE_VAULT') {\n    (async () => {\n      try {\n        const restored = await restoreVaultForAutofill();\n        sendResponse({ success: restored });\n      } catch (error) {\n        console.error('[Background] Error restoring vault:', error);\n        sendResponse({ success: false, error: error instanceof Error ? error.message : 'Unknown error' });\n      }\n    })();\n    return true;\n  }\n\n  // Handle vault sync from popup\n  if (msg.type === 'SYNC_VAULT' && msg.vaultData) {\n    (async () => {\n      try {\n        // Import the memory module to store vault data\n        const { setCredentialsInMemory, setBankCardsInMemory, setSecureNotesInMemory } = await import('./session/memory');\n        \n        setCredentialsInMemory(msg.vaultData.credentials || []);\n        setBankCardsInMemory(msg.vaultData.bankCards || []);\n        setSecureNotesInMemory(msg.vaultData.secureNotes || []);\n        \n        console.log('[Background] Vault synced from popup');\n        sendResponse({ success: true });\n      } catch (error) {\n        console.error('[Background] Error syncing vault from popup:', error);\n        sendResponse({ success: false, error: error instanceof Error ? error.message : 'Unknown error' });\n      }\n    })();\n    return true;\n  }\n});\n\n// Handle tab updates to clean up page state\nchrome.tabs.onRemoved.addListener((tabId) => {\n  delete pageState[tabId];\n  activeContentScriptTabs.delete(tabId);\n  console.log('[Background] Tab removed, cleaned up state for tab:', tabId);\n});\n\n// Handle extension startup\nchrome.runtime.onStartup.addListener(() => {\n  console.log('[Background] Extension started, loading vault...');\n  ensureVaultLoaded();\n});\n\n// Handle extension installation/update\nchrome.runtime.onInstalled.addListener(() => {\n  console.log('[Background] Extension installed/updated, loading vault...');\n  ensureVaultLoaded();\n});\n\n// Handle tab activation to ensure vault is loaded\nchrome.tabs.onActivated.addListener(() => {\n  console.log('[Background] Tab activated, ensuring vault is loaded...');\n  ensureVaultLoaded();\n});\n\n// Handle tab updates to ensure vault is loaded\nchrome.tabs.onUpdated.addListener((tabId, changeInfo) => {\n  if (changeInfo.status === 'complete') {\n    console.log('[Background] Tab updated, ensuring vault is loaded for tab:', tabId);\n    ensureVaultLoaded();\n  }\n});\n"],"file":"background.js"}